2 ways to create threads :-
	1. extends Thread class -
		Starting thread - NewThreadClass t1 = new NewThreadClass();
							t1.start();
		Example :- org.example.ThreadCreationExample1

	2. Implement Runnable interface -
		starting thread - Thread t = new Thread(new NewRunnableThread);
							t.start()
        Example :- org.example.ThreadCreationExample2

Thread vs Runnable :-
    - Thread represents actual thread which runs and it has all the methods supported by threads. Runnable on other hand represents task.
    - When we use threads we cannot differentiate tasks , we have to tasks within thread only, this might affect quality of code and usability. With runnable we can separate
     out task from Thread.
    - Resource sharing between multiple threads become easies with runnable.
    - If you want to enhance Thread or override ny property of method that time we should think of using extending threads otherwise use runnable.

Join :-
    thread.join() method will tell currently executing thread to wait for this thread (thread on which join method is called) to finish its job.
    Example :- org.example.JonExample

Volatile keyword :-
    Volatile means read from main memory not from CPU registers since in multicore system each cpu has its own register to store data.

	Sometimes on some systems it might happen that some shared data or data which is going to be updated by another thread is cached by running thread and never check for
	updated value. Or Code might interpreted in such a way that system might feel that data which is shared or getting updated by another thread is useless and because of
	this system might never check its updated value . In such case we should use volatile keyword on those shared data. It can happen on some systems, its not always true
	for all systems.
    Example :- org.example.VolatileExample
    https://jenkov.com/tutorials/java-concurrency/volatile.html

synchronized keyword on method :-
	Every object in java has intrinsic lock. At a time only one thread can acquire this lock. When we mark any method synchronized then thread has to aquire this intrensic lock inorder do any processing on tht object.

	When we use synchronized keyword on method then we don't need to use volatile keyword for shared data, by default that shared data is monitored by all the threads

	Case : If class has 2 synchronized methods and if 2 threads want to access them then at a time only 1 thread can access one of the thread. If 1 thread is accessing one method then other thread cannont access same or other synchrozed method.

	void synchronized method1(){
		//do stuff
	}

	void synchronized method2(){
		//do stuff
	}

	Solution : To solve this we can use synchronized lock on separate objects.

	Object o1 = new Object();
	Object o2 = new Object();

	void method1(){
		synchronized(o1){
			//do stuff
		]
	}

	void method2(){
		synchronized(o2){
			//do stuff
		]
	}

	Example :- Follow example present in package src/main/java/org/example/synchronizedExample

	synchronized method example present in following class :- Example1, Example2, SynchronizedMethod

	synchronized block (object lock) example present in following class :- Example3, Example4, Example5, Example6, Example7

	synchronized block (class level lock) example present in following class :- Example8 , Example9

Executor Framework :-
    It is created to use existing threads rather than creating new threads every time. It works on concept of thread pooling. It uses
    existing thread from thread pool to execute task.

    Executor and ExecutorService are interface.
    Executors is class which provide factory methods to create thread pools.
    4 Types of ExecutorService are available
        - SingleThreadPool : Thread poo with single thread.
        - FixedThreadPool : Thread pool with fixed number of threads
        - CachedThreadPool : Creates thread pool which creates new thread if require else will use existing one. If no thread is available
                in thread pool then it creates new one.
        - ScheduledExecutor : We can use this when task needs to be run at a regular interval or if we want to delay a task.

    Example :- src/main/java/org/example/threadpool

    Future object :- We can access result of a task submitted to executor using Future<> object. If we want result the we should
    implement Callable interface instead of Runnable for task.

    Example : org.example.threadpool.FuturesExample

    shutdown method in ExecutorService : If we don't call it then executors keeps running in background. Once we call this executor will
        not accept new tasks and shuts down.

    awaitTermination : Program waits at this for given amount of time or all tasks gets completed.  When time gets completed program
        resumes from this point but in background executors stays alive. so to kill or shut down executor threads we need to call
        shutdown method.

CountDown latch :-
     It helps if any thread wants to wait for other n number of threads to complete its tasks. When we create countDown latch we
     provide number then we pass this latch object to all those threads on which we are dependent. Then once thread completes their
     tasks it decrements count by 1. Like this all threads decrements latch by 1 one. When latch reaches to zero thread which is waiting
     resumes and starts running.

     Example : org.example.CountDownLatchExample

 Producer Consumer problem :-
    Producer consumer problem is best solved by using blocking queue.
    Example : org.example.producerconsumer.ProducerConsumerUsingQueue