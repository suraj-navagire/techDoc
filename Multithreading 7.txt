2 ways to create threads :-
	1. extends Thread class -
		Starting thread - NewThreadClass t1 = new NewThreadClass();
							t1.start();
	2. Implement Runnable interface -
		starting thread - Thread t = new Thread(new NewRunnableThread);
							t.start()
							
							
Volatile keyword :- 
	Sometimes on some systems it might happen that some shared data or data which is going to be updated by another thread is cached by running thread and never check for updated value. Or Code might interpreted in such a way that system might feel that data which is shared or getiing updted by another thread is useless and becuase of this system might never check its updated value . In such case we should use volatile keyword on those shared data. It can happen on some systems, its not always true for all systems.

synchronized keyword on method :-
	Every object in java has intrensic lock. At a time only one thread can aquire this lock. When we mark any method synchronized then thread has to aquire this intrensic lock inorder do any processing on tht object.
	
	When we use synchrozed keyword on method then we dont need to use volatile keyword for shared data, by default that shared data is monitored by all the threads
	
	Case : If class has 2 synchrozed methods and if 2 threads want to access them then at a time only 1 thread can access one of the thread. If 1 thread is accessing one method then other thread cannont access same or other synchrozed method.
	
	void synchronized method1(){
		//do stuff
	}
	
	void synchronized method2(){
		//do stuff
	}
	
	Solution : To solve this we can use synchronized lock on seperate objects.
	
	Object o1 = new Object();
	Object o2 = new Object();
	
	void method1(){
		synchronized(o1){
			//do stuff
		]
	}
	
	void method2(){
		synchronized(o2){
			//do stuff
		]
	}