This project is created to practice data structures and algorithms

Learning path to be followed :-
https://instabyte.io/p/dsa-master

Data structures:-

Progress:-
1. Arrays -
            Array is collection similar data type stored in a contiguous memory location. It is a linear data structure. It is a static data structure with a fixed size.
            Operations :-
                1. Traversal - Visiting each element of an array in a specific order [sequential or reversal].
                2. Insertion - Adding new element to an array at a specific index.
                3. Deletion - Removing an existing element from an array at a specific index.
                4. Searching - Finding the index of an element in an array.
                5. Retrieval - Returning an element present at a specific index from an array.
            Advantages :-
                1. Retrieval of an element is faster.
                2. Requires less memory compared with linked list.
            DisAdvantages :-
                1. Adding new element is slow.
                2. Deleting existing element is slow.
                3. When array is initialized memory gets reserved even if element is not added.
            Example :- src/main/java/com/datastructures/Array.java

2. Linked List -
            Linked list is a linear data structure consists of series of nodes connected by references. Node consists of data and reference to the next node. It doesn't
            store node in a contiguous memory location.
            Operations :-
                1. Traversal - Visiting each element of a linked list in a specific order.
                2. Insertion - Adding new element to a linked list.
                3. Deletion - Removing existing element from a linked list.
                4. Searching - Finding the element in a linked list.
                4. Retrieval - Returning an element present at a specific index.
            Advantages :-
                1. Adding new element is faster/efficient.
                2. Removing existing element is faster/efficient.
            Disadvantages :-
                1. Retrieving element from a specific index is costly.
                2. Traversal is slow.
            Example :- src/main/java/com/datastructures/SinglyLinkedList.java, src/main/java/com/datastructures/DoublyLinkedList.java

3. Hash Table -
            Hash table is data structure used to store element in such a way that searching becomes fast.
            Hash table step :-
                1. Calculate hash of element using hash function.
                2. Calculate index within the size of table using evaluated hash value.
                3. Store the element at that derived index location.
                4. If collision happens then use one of the collision handling technique called separate chaining. In this technique use linked list to store data at that
                index location.

                Hash table :- Node<K>[] table;
                Node :- {k element, int hash, Node nextNode}

                function insert(k element){
                    int hash = hash(element);
                    int index = hash % (table.size-1);

                    if(table[index] == null){
                        // add element to this location;
                    } else {
                        // add element to next node provided next node is null else keep moving to next node till we get next node as null;
                    }
                }
            Advantages :-
                1. Hash table is very useful when we want to perform searching specially unsorted collection.
            Example :- src/main/java/com/datastructures/HashTable.java
                    https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/

4. Tree -
            It is non linear data structure consists of nodes connected by edges. It allow faster and quicker access to element as it is non linear in nature.

            Node :- It contains key/data along with pointers to child nodes. Last node is called leaf node which don't point to any other node.
                The node with at least one child is called internal node.
            Edge :- It is the link between any 2 node.

            Root :- It is the top most node of a tree.

            Height of node :- It is the number edges from node to the farthest leaf node of that node.

            depth of node :- It is the number of edges from root to that node.

            Height of tree :- It is the number of edges from root node to farthest leaf node.

            Forest :- A collection of disjoint trees.

            Types of tree :-
                1. Binary Tree - Binary tree is a tree in which each node can have at most 2 children.
                2. Binary search tree - It allows us to maintain sorted list of elements quickly. time complexity for search is O(log(n))
                3. AVL tree
                4. B-tree

            Tree traversing Techniques :-
                1. Inorder (DFS):-
                    i. Traverse left subtree
                    ii. Visit root node
                    iii. Traverse right subtree
                2. PreOrder (DFS) :-
                     i.   Visit root node
                     ii.  Traverse left subtree
                     iii. Traverse right subtree
                3. PostOrder (DFS):-
                    i.  Traverse left subtree
                    ii. Traverse right subtree
                    iii. Visit root node
                4. Breath first search :- Print node from left to right i.e. breath first from root node to leaf node

            Example :- https://www.programiz.com/dsa/trees,
                       com.datastructures.application.BinarySearchTreeApplication


5. Stacks -
            Stack is linear data structure which used to store and manage data, which follows last in first out(LIFO) or First in last out(FILO) order.

            Operations supported by stack:-
                1. Push : Adds element at top of the stack.
                2. Pop : Removes and returns element presents at top of the stack.
                3. Peek : Returns element present at top of the stack without removing it.
                4. IsEmpty : Returns boolean true if stack is empty.
                5. IsFull : Returns boolean true if stack is full if fixed size collection is used i.e. array.

            Example : com.datastructures.application.StackArrayImplementationApplication,
                        com.datastructures.application.StackLinkedListImplementationApplication

6. Queues -
            Queue is a linear data structure which used to store and manage data which follows first in first out (FIFO) or last in last out(LILO) order

            Operations supported by queue :-
                1. Enqueue : Adds element to the tail of the queue.
                2. Dequeue : Removes and returns element from the head of the queue.
                3. Peek : Returns element from the head of the queue.
                4. isEmpty : Returns boolean true if queue is empty.
                5. isFull : Returns boolean true if queue is full.
--------------------------------

Algorithms:-

Progress :-
1. Reservoir sampling -
            This algorithm is used to randomly pick k elements from a large list. Usually this list is big enough that it will not fit into memory. So we need algorithm
            through which only in one iteration we will be able to pick k elements with each element getting picked-up with probability k/n where k is number of elements
            picked-up and n is total number of elements.

            Case 1:- Select 1 element randomly from list(might be stream where we don't know size) where probability of i'th element getting selected is 1/n

                int selectRandom(List arr){
                    int randomNumber = -1;
                    Random rand = new Random();
                    int i=0;
                    while(arr.hasNext()){
                        i++;
                        int random = rand.nextInt(i); //Within the range of i. This will return from 0 to i-1.
                        int num = listIterator.next();

                        //Probability of random number will be i-1 is 1/n.  Total number is n and range is 1 then probability will be 1/n
                        if(random == (i-1)){
                            randomNumber = num;
                        }
                    }

                    return randomNumber;
                }

                proof :- p(A of i) getting selected is p(A is getting selected at i position ) * p(A is not getting selected at i+1, i+2,...n) position
                        p(A of i) = 1/i * (1 - 1/i+1) * (1- 1/i+2) * ....* (1 - 1/n-1) * (1 - 1/n)
                        p(A of i) = 1/i * (i/i+1) * (i+1/i+2) * ....* (n-2/n-1) * (n-1/n)
                        p(A of i) = 1/i * (i/i+1) * (i+1/i+2) * ....* (n-2/n-1) * (n-1/n)
                        p(A of i) = 1/n

            Case 2 :-   Select k elements randomly from list(might be stream where we don't know size) where probability of i'th element getting selected is k/n

                int[] selectRandomK(List arr, int k){
                    int[] selectedRandomNumber = new int[k];

                    for(int i=0;i<k;i++){
                        selectedRandomNumber[i] = arr[i];
                    }
                    Random rand = new Random();

                    //After this i will be i=k
                    while(arr.hasNext()){
                        int random = rand.nextInt(i); //Within the range of i. This will return from 0 to i-1.
                        int num = listIterator.next();

                        //Probability of random number will be less than k is k/n. Total number is n and range is k then probability will be k/n
                        if(random < k){
                            selectedRandomNumber[random] = num;
                        }
                    }

                    return selectedRandomNumber;
                }

                proof :- p(A of i) getting selected is p(A is getting selected at i position ) * p(A is not getting selected at i+1, i+2,...n) position
                          For first k element , p(A of i ) = 1;
                          For k<i<n is ,(Note after this i will be k+1)
                          p(A of i) = k/k+1 * (1 - k/k+2) * (1- k/k+3) * ....* (1 - k/n-1) * (1 - k/n)
                          p(A of i) = k/k+1 * (2/k+2) * (3/k+3) * ....* (n-2/n-1) * (n-1/n)
                          p(A of i) = k/n

            Example : com.algorithms.ReservoirSampling