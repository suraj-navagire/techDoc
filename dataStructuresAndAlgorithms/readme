This project is created to practice data structures and algorithms

Learning path to be followed :-
https://instabyte.io/p/dsa-master

Data structures:-

Progress:-
1. Arrays -
            Array is collection similar data type stored in a contiguous memory location. It is a linear data structure. It is a static data structure with a fixed size.
            Array.length method gives size of array not number of elements inserted in array.
            Operations :-
                1. Traversal - Visiting each element of an array in a specific order [sequential or reversal].
                2. Insertion - Adding new element to an array at a specific index.
                3. Deletion - Removing an existing element from an array at a specific index.
                4. Searching - Finding the index of an element in an array.
                5. Retrieval - Returning an element present at a specific index from an array.
            Advantages :-
                1. Retrieval of an element is faster.
                2. Requires less memory compared with linked list.
            DisAdvantages :-
                1. Adding new element is slow.
                2. Deleting existing element is slow.
                3. When array is initialized memory gets reserved even if element is not added.
            Example :- src/main/java/com/datastructures/Array.java

2. Linked List -
            Linked list is a linear data structure consists of series of nodes connected by references. Node consists of data and reference to the next node. It doesn't
            store node in a contiguous memory location.
            Operations :-
                1. Traversal - Visiting each element of a linked list in a specific order.
                2. Insertion - Adding new element to a linked list.
                3. Deletion - Removing existing element from a linked list.
                4. Searching - Finding the element in a linked list.
                4. Retrieval - Returning an element present at a specific index.
            Advantages :-
                1. Adding new element is faster/efficient.
                2. Removing existing element is faster/efficient.
            Disadvantages :-
                1. Retrieving element from a specific index is costly.
                2. Traversal is slow.
            Example :- src/main/java/com/datastructures/SinglyLinkedList.java, src/main/java/com/datastructures/DoublyLinkedList.java

3. Hash Table -
            Hash table is data structure used to store element in such a way that searching becomes fast.
            Hash table step :-
                1. Calculate hash of element using hash function.
                2. Calculate index within the size of table using evaluated hash value.
                3. Store the element at that derived index location.
                4. If collision happens then use one of the collision handling technique called separate chaining. In this technique use linked list to store data at that
                index location.

                Hash table :- Node<K>[] table;
                Node :- {k element, int hash, Node nextNode}

                function insert(k element){
                    int hash = hash(element);
                    int index = hash % (table.size-1);

                    if(table[index] == null){
                        // add element to this location;
                    } else {
                        // add element to next node provided next node is null else keep moving to next node till we get next node as null;
                    }
                }
            Advantages :-
                1. Hash table is very useful when we want to perform searching specially unsorted collection.
            Example :- src/main/java/com/datastructures/HashTable.java
                    https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/

4. Tree -
            It is non linear data structure consists of nodes connected by edges. It allow faster and quicker access to element as it is non linear in nature.

            Node :- It contains key/data along with pointers to child nodes. Last node is called leaf node which don't point to any other node.
                The node with at least one child is called internal node.
            Edge :- It is the link between any 2 node.

            Root :- It is the top most node of a tree.

            Height of node :- It is the number edges from node to the farthest leaf node of that node.

            depth of node :- It is the number of edges from root to that node.

            Height of tree :- It is the number of edges from root node to farthest leaf node.

            Forest :- A collection of disjoint trees.

            Types of tree :-
                1. Binary Tree - Binary tree is a tree in which each node can have at most 2 children.
                2. Binary search tree - It allows us to maintain sorted list of elements quickly. time complexity for search is O(log(n))
                3. AVL tree
                4. B-tree

            Tree traversing Techniques :-
                1. Inorder (DFS):-
                    i. Traverse left subtree
                    ii. Visit root node
                    iii. Traverse right subtree
                2. PreOrder (DFS) :-
                     i.   Visit root node
                     ii.  Traverse left subtree
                     iii. Traverse right subtree
                3. PostOrder (DFS):-
                    i.  Traverse left subtree
                    ii. Traverse right subtree
                    iii. Visit root node
                4. Breath first search :- Print node from left to right i.e. breath first from root node to leaf node

            Binary Tree representation using array :-
                Root location = 0;
                Left children of i = 2*i + 1
                Right children of i = 2*1 + 2
                Parent of i = (i-1)/2
            Example :- https://www.programiz.com/dsa/trees,
                       com.datastructures.application.BinarySearchTreeApplication
                       com.datastructures.application.BinaryTreeArrayImplementationExample
                       com.datastructures.application.MaxHeapApplication


5. Stacks -
            Stack is linear data structure which used to store and manage data, which follows last in first out(LIFO) or First in last out(FILO) order.

            Operations supported by stack:-
                1. Push : Adds element at top of the stack.
                2. Pop : Removes and returns element presents at top of the stack.
                3. Peek : Returns element present at top of the stack without removing it.
                4. IsEmpty : Returns boolean true if stack is empty.
                5. IsFull : Returns boolean true if stack is full if fixed size collection is used i.e. array.

            Example : com.datastructures.application.StackArrayImplementationApplication,
                        com.datastructures.application.StackLinkedListImplementationApplication

6. Queues -
            Queue is a linear data structure which used to store and manage data which follows first in first out (FIFO) or last in last out(LILO) order

            Operations supported by queue :-
                1. Enqueue : Adds element to the tail of the queue.
                2. Dequeue : Removes and returns element from the head of the queue.
                3. Peek : Returns element from the head of the queue.
                4. isEmpty : Returns boolean true if queue is empty.
                5. isFull : Returns boolean true if queue is full.

            Example : com.datastructures.application.QueueArrayImplementationApplication
                        com.datastructures.application.QueueLinkedListImplementationApplication

7. Heaps (Priority queues) -
            Heap is a binary tree data structure which satisfies heap property for every node.

            Types of heap :-
                1. Max heap : In this type of heap every node is greater than or equal to its children. So in type of heap root contains maximum value.
                2. Min heap : In this type of heap every node is less than or equal to its children. So in this type of heap root contains minimum value.

            Operations supported by heap :-
                1. Insert : Add new element to heap maintaining heap property.
                2. Extract min/max : Removes maximum or minimum element from the heap and return it.
                3. Heapify : Converts an arbitrary binary tree into a heap.

            Algorithm (Max heap)-
                1. Insert :
                    Steps :- 1. Insert element at last position.
                             2. Compare it with its parent .
                             3. If element is greater than parent swap it.
                             4. Keep performing steps from step 2 till no more swap needed or element reaches 0 index.

                2. Delete (Extract Max) :
                    Steps :- 1. Remove element from 0 index which is root node. This node is max node.
                             2. Take last index element and put it in 0 index.
                             3. Now compare this swapped element with its children.
                             4. First compare both the children with each other. Select maximum element. Then compare this max element with swapped element.
                             5. If swapped element is less than selected element then swap.
                             6. Keep performing steps from step 3 till we reach state that there is no more swap needed.
                             7. Return removed element in step 1.

                3. Heapify : Heapify is a process of converting given binary tree into a heap.
                    Steps :- 1. Start from last element to 0 element
                             2. See if children are present for that current element.
                             3. If children are present then compare both the children and find max element.
                             4. Compare that max element with current element.
                             5. If children is grater then swap.
                             6. Keep performing steps from 2 till we reach state that there is no more swap needed and we reach index 0.

                4. Heap sort : We can use deletion of element process for sorting. Whatever element we will delete we will put it at recently vacant location.
                    Steps :- 1. lastIndex = currentLastIndex;
                             2. Remove element from 0 index.
                             2. Take element from lastIndex and put it at 0 index.
                             3. Now keep removed element from step 2 at lastIndex location.
                             4. lastIndex--;
                             5. Now follow "Delete" algorithm present above to adjust elements position present at 0 index. Follow from step 3 of "Delete algorithm".
                             6. Keep performing steps from step 2 till we reach where lastIndex = 0;
                             7. By doing this we will make array sorted in ascending order.

                5. Priority queues : Priority queue is nothing but heap. Depending upon application. If less value means highest priority then use min heap.
                        If max value means highest priority then use max heap.
                        - When we dequeue element from heap then we will get max or min depending upon heap, While returning and deleting this element we adjust tree
                         to satisfy heap property like "Delete " operation.
                        - Every time we do queue we get highest priority element.
                        - Use com.datastructures.application.MaxHeap class and use insert method as enqueue and extractMax as dequeue.

                Example :- com.datastructures.application.MaxHeapApplication
                    https://youtu.be/HqPJF2L5h9U?si=4P95IM0eqcxX02lk



--------------------------------

Algorithms:-

Progress :-
1. Reservoir sampling -
            This algorithm is used to randomly pick k elements from a large list. Usually this list is big enough that it will not fit into memory. So we need algorithm
            through which only in one iteration we will be able to pick k elements with each element getting picked-up with probability k/n where k is number of elements
            picked-up and n is total number of elements.

            Case 1:- Select 1 element randomly from list(might be stream where we don't know size) where probability of i'th element getting selected is 1/n

                int selectRandom(List arr){
                    int randomNumber = -1;
                    Random rand = new Random();
                    int i=0;
                    while(arr.hasNext()){
                        i++;
                        int random = rand.nextInt(i); //Within the range of i. This will return from 0 to i-1.
                        int num = listIterator.next();

                        //Probability of random number will be i-1 is 1/n.  Total number is n and range is 1 then probability will be 1/n
                        if(random == (i-1)){
                            randomNumber = num;
                        }
                    }

                    return randomNumber;
                }

                proof :- p(A of i) getting selected is p(A is getting selected at i position ) * p(A is not getting selected at i+1, i+2,...n) position
                        p(A of i) = 1/i * (1 - 1/i+1) * (1- 1/i+2) * ....* (1 - 1/n-1) * (1 - 1/n)
                        p(A of i) = 1/i * (i/i+1) * (i+1/i+2) * ....* (n-2/n-1) * (n-1/n)
                        p(A of i) = 1/i * (i/i+1) * (i+1/i+2) * ....* (n-2/n-1) * (n-1/n)
                        p(A of i) = 1/n

            Case 2 :-   Select k elements randomly from list(might be stream where we don't know size) where probability of i'th element getting selected is k/n

                int[] selectRandomK(List arr, int k){
                    int[] selectedRandomNumber = new int[k];

                    for(int i=0;i<k;i++){
                        selectedRandomNumber[i] = arr[i];
                    }
                    Random rand = new Random();

                    //After this i will be i=k
                    while(arr.hasNext()){
                        int random = rand.nextInt(i); //Within the range of i. This will return from 0 to i-1.
                        int num = listIterator.next();

                        //Probability of random number will be less than k is k/n. Total number is n and range is k then probability will be k/n
                        if(random < k){
                            selectedRandomNumber[random] = num;
                        }
                    }

                    return selectedRandomNumber;
                }

                proof :- p(A of i) getting selected is p(A is getting selected at i position ) * p(A is not getting selected at i+1, i+2,...n) position
                          For first k element , p(A of i ) = 1;
                          For k<i<n is ,(Note after this i will be k+1)
                          p(A of i) = k/k+1 * (1 - k/k+2) * (1- k/k+3) * ....* (1 - k/n-1) * (1 - k/n)
                          p(A of i) = k/k+1 * (2/k+2) * (3/k+3) * ....* (n-2/n-1) * (n-1/n)
                          p(A of i) = k/n

            Example : com.algorithms.ReservoirSampling


2. Heap sort -
            Check Heap section present under Data Structure above.
            Steps for heap sort :-
                1. Heapify given array/tree. To heapify each element it takes lon N time. So to heapify entire array with size N it will take -> N log N
                2. Iterate N times and extract element from root i.e. 0 index and put it on current last index. For each extraction it will take log N time
                    So for entire it will take N log N
                3. Total time -> N log N + N log N (i.e. step1 and step 2 time ) => 2 N log N => O(NlogN)

            Example :- com.algorithms.HeapSortApplication
                        https://youtu.be/HqPJF2L5h9U?si=4P95IM0eqcxX02lk
