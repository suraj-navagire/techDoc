This project is created to provide understanding of design patterns.

What is design pattern:-
    Design pattern is a solution to commonly occurring problems in a software design. They are like pre made blue print which
    you can customize to solve design problems in your code.

SOLID principle in software design:- These are the design principles that needs to be consider while designing the software
1. Single responsibility principle -
        A class should have only one reason to change. i.e. A class should have only one job to do or one task or one purpose.
        Example :- com.patterns.solid.SingleResponsibilityViolation,
                    com.patterns.solid.SingleResponsibilityCorrect

2. Open/Closed principle -
        A class should be open for extension but closed for modification. Suppose if you have PaymentProcessor which contains
        code to process payment of credit card. In future if we want to add phonepe payment then if we add that code in same class
        then it is violation of open/closed principle. Instead we should write a parent interface PaymentProcessor and implement this
        using new new payment processor's. In this way its easy to add new payment methods without changing existing classes.
        Example :- com.patterns.solid.OpenClosedViolation,
                    com.patterns.solid.OpenClosedCorrect

3. Liskov substitution principle -
        It states that object of superclass can be replaced by object of sub class without affecting correctness of a program.
        Example :- com.patterns.solid.LiskovSubstitutionCorrect,
                    com.patterns.solid.LiskovSubstitutionViolation

4. Interface segregation principle -
        This principle states that interface should be segregated properly. This principle is similar to single responsibility principle.
        One interface should not contain all the method just for the sake of having. It should have only required and relevant methods.
        Methods should be segregated in multiple interfaces as per requirement.
        Example :- com.patterns.solid.InterfaceSegregationViolation,
                    com.patterns.solid.InterfaceSegregationCorrect

5. Dependency Inversion Principle -
        It states that high level module should not depend on low level module, Both should depend on abstraction.
        Example :- com.patterns.solid.DependencyInversionViolation,
                    com.patterns.solid.DependencyInversionCorrect

--------------------------------------------------------------

There are 3 categories of design patterns:-

https://www.digitalocean.com/community/tutorials/java-design-patterns-example-tutorial
https://www.youtube.com/watch?v=4ff_KZdvJn8

1. Creational design pattern -
        Creational design pattern gives us best possible way to instantiate an object in a specific situation.

        1. Singleton design pattern :- Singleton design pattern restricts instantiation of an object. It allows only one instance of a class
            inside a java virtual machine.
            Example :- com.patterns.creational.singleton.EagerInitialization,
                        com.patterns.creational.singleton.EagerInitializationIssueExample,
                        com.patterns.creational.singleton.StaticBlockInitialization,
                        com.patterns.creational.singleton.LazyInitialization,
                        com.patterns.creational.singleton.ThreadSafeInitialization,
                        com.patterns.creational.singleton.StaticInnerClassInitialization

            Reflection, Deserialization and cloning are 3 ways to broke singleton.

            Reflection :- In reflection we can make constructor accessible by making it's visibility true.
                          To overcome reflection issue we can use Enum or we can throw Exception from constructor if instance variable is not null.

            Deserialization :- When we do deserialization of serialized object it creates new object.
                            To overcome this issue we can use "readResolve" method.

            Cloning :- In cloning we can create clone of a object using clone method.
                        We can overcome this using overriding clone method and throwing "clone not supported Exception".

            Example :- com.patterns.creational.singleton.FinalSingleton

        2. Factory pattern (Factory method):- When we have a situation where we have super class and multiple subclasses and base on input we have to return
            one of the subclass. This pattern takes out responsibility of instantiation of subclasses from clients code to factory class.
            We can use singleton pattern on factory class or make the factory method static.

            Example :- com.patterns.creational.factoryPattern.ComputerTest

        3. Abstract Factory :- It add another layer on top of factory pattern. Abstract factory return factory class, This returned factory class will return
            desired object.

            Example :-  com.patterns.creational.abstractFactory.ShapeTest,
                    https://www.youtube.com/watch?v=5hXZnI86E2Y

        4. Builder design pattern :- Builder design pattern helps in creation of complex objects
            Builder design patter should be used in following scenario :-
                1. When we want to create complex objects like large number of constructor parameters,
                    Possibilities of having new properties or attributes in future, Not All constructor
                    arguments are mandatory.
                2. When we want object similar like immutable.

            Example :- https://www.youtube.com/watch?v=4ff_KZdvJn8,
                        com.patterns.creational.builder.URLWithBuilder

        5. Prototype design pattern :- If we have a design requirement where we have to create copies of objects of a class
            then we can use prototype design pattern. If we don't then we will have to write so much redundant code to make copy of
            objects.
            Implement cloneable interface where we have to achieve prototype pattern. Classes which implements cloneable are known as prototypes.
            Cloning is nothing but copying. There are 2 types of copy. Shallow and deep.

            Shallow copy :- If we implement Cloneable interface and override Clone method then default implementation will give shallow copy feature.
                Example :- com.patterns.creational.prototype.CompanyShallowExample
            Deep copy :- If we implement Cloneable interface and override Clone method then Along with default implementation clone all non primitive and non immutable fields explicitly.
                Example :- com.patterns.creational.prototype.CompanyDeepExample

            We can create copy using copy constructors as well. This is more advantageous then implementing cloneable.

            Following is the most useful example of prototype
            Example :- com.patterns.creational.prototype.copyConstructor.PrototypeTest

2. Structural design pattern :-
        Structural design pattern provides different ways to create a class structure ( For example using inheritance and composition to create large objects from small small
        objects)

        1. Adapter design pattern :-  Adapter design pattern is a structural design pattern that allows objects with different interfaces to collaborate.
            It acts as a bridge between 2 incompatible interfaces by converting the interface of one class into another interface.
            This use useful when we want to reuse the existing classes without modifying their code, but their interface doesn't match with the requirements of client.

            Example : com.patterns.structural.adapter.Client

        2. Bridge design pattern :-
            Problem solved by bridge :
            1. Suppose if have a requirement to make a system to draw different shapes. What you will do. You will make shape interface. Then you will add its implementations.
            consider initially you have created 2 shapes Triangle and Square.
            2. Now consider in future client wants red color and blue colored shapes. Then what you will do, in order to reuse the shape making code you will create new class
            which will extend the existing shapes i.e. You will make RedTriangleShape which will extend TriangleShape,  BlueTriangleShape which will extend TriangleShape,
            RedSquareShape which will extend SquareShape, BlueSquareShape which will extend SquareShape.
            3. Till now you will feel like you have designed great system but wait what if in future client will add more shape and more colors.
                consider even if client demands 2 more shape and 2 more colors then you will end up having
                total shapes = 4
                total colors = 4
                Total colored shape classes = 16 i.e. cartesian product.
            Then you will realize how messy system.

            Example : com.patterns.structural.bridge.problem.Client

            Solution :
            1. First understand the problem.
            2. Here drawing shape and coloring it are 2 different tasks. This we can decouple.
            3. Create Color interface and create its implementations.
            4. Use association over inheritance i.e. add color object inside shape.
            5. Make shape as abstract class so that it can contain Color, and write its implementations.
            6. Pass color object at the time of creating shape
            7. Here if you want to add more 2 color then you will have to create only 2 color classes not more. You can pass color object to shape at the time of creation
            If you want to add more 2 shapes then also you will have to create only 2 classes.

            Elements of Bridge design patterns :
                1. Implementor - Functionality which we are separating out/decoupling. Here Color is the implementor
                2. Concrete implementation - Concrete classes which implements implementor. Here RedColor and BlueColor
                3. Abstraction - Core of the bridge design pattern. It holds the instance of implementor. It provides abstract method
                which is used by client. Here 'Shape' class. 'draw()' is the method which is providing abstraction to client.
                Also Shape class delegate draw() call to color object.
                4. Concrete abstraction - Concrete classes which extends abstract class. It uses concrete implementor objects to do work.
                Here it uses RedColor or BlueColor to fill color.

            Example : com.patterns.structural.bridge.solution.Client

